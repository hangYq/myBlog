(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{225:function(t,s,a){"use strict";a.r(s);var r=a(0),e=Object(r.a)({},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"js模块化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js模块化","aria-hidden":"true"}},[t._v("#")]),t._v(" js模块化")]),t._v(" "),a("h4",{attrs:{id:"一、commonjs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、commonjs","aria-hidden":"true"}},[t._v("#")]),t._v(" 一、CommonJs")]),t._v(" "),a("p",[t._v('node.js的出现标志着"javaScript模块化编程"的正式诞生。因为老实说，在浏览器环境下，没有模块化并没有什么太大的影响，毕竟网页应用程序的复杂性有限。但是在服务端，一定要有模块化，与操作系统和其他应用程序互动，否则根本没法编程。Node.js是CommonJs规范的实现，webpack也是CommonJs规范的实现。')]),t._v(" "),a("h5",{attrs:{id:"_1-commonjs定义的模块分为："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-commonjs定义的模块分为：","aria-hidden":"true"}},[t._v("#")]),t._v(" 1. CommonJs定义的模块分为：")]),t._v(" "),a("pre",[a("code",[t._v("① 模块引用：require，require用来引入外部模块（`require是同步的`）\n② 模块定义：exports，exports对象用来导出当前模块的方法和变量，唯一的导出口\n③ 模块表示： module，module对象就代表模块本身\n")])]),t._v(" "),a("h4",{attrs:{id:"_2-浏览器不兼容commonjs的原因："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-浏览器不兼容commonjs的原因：","aria-hidden":"true"}},[t._v("#")]),t._v(" 2. 浏览器不兼容CommonJs的原因：")]),t._v(" "),a("p",[t._v("浏览器不兼容CommonJs的根本原因，在与浏览器缺少四个node.js环境的变量：")]),t._v(" "),a("ol",[a("li",[t._v("module")]),t._v(" "),a("li",[t._v("exports")]),t._v(" "),a("li",[t._v("require")]),t._v(" "),a("li",[t._v("global")])]),t._v(" "),a("p",[t._v("注意：")]),t._v(" "),a("pre",[a("code",[t._v("只要能够提这四个变量，浏览器就可以加载CommonJs模块。\n")])]),t._v(" "),a("h4",{attrs:{id:"二、amd"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、amd","aria-hidden":"true"}},[t._v("#")]),t._v(" 二、AMD")]),t._v(" "),a("h5",{attrs:{id:"_1-amd的出现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-amd的出现","aria-hidden":"true"}},[t._v("#")]),t._v(" 1. AMD的出现")]),t._v(" "),a("p",[t._v("基于"),a("code",[t._v("CommonJs")]),t._v("的"),a("code",[t._v("node.js")]),t._v("出来以后，服务端的模块概念已经形成，很自然大家就想要客户端模块。而且最好两者可以兼容，一个模块不用修改，在服务端和浏览器都可以运行。但是有一个很大的局限，使得CommonJs规范不适用于浏览器。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" math "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'math'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    math"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("第二行math.add(1,2)必须在第一行require加载完成后，才可以执行，也就是说如果加载时间很长，浏览器就会在哪里等待，因为在CommonJs中require是同步的。")]),t._v(" "),a("p",[t._v("上面的问题对于服务端不是一个问题，因为所有的文件都存放在本地硬盘里，可以同步加载完成，等待的时间就是硬盘的读取时间。但是对于浏览器而言，是一个大的问题，因为所有的文件都是放在服务器，等待的时间取决于网络，可能需要等待的时间比较久，浏览器处于假死状态。")]),t._v(" "),a("p",[t._v("因此浏览器的模块不能采用同步加载，只能使用异步方式。这就是AMD诞生的背景。")]),t._v(" "),a("p",[t._v("CommonJs的实现是为了后端实现而制定的，它不适合前端，AND(异步模块定义)的出现就是为了前端实现而制定的规范。")]),t._v(" "),a("p",[t._v('AMD是"Asynchronous Module Definition"的缩写，意思就是"异步模块定义"。它采用的是异步方式加载模块，模块的加载不影响它后面的语句的执行，所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成后，才会调用这些语句。')]),t._v(" "),a("p",[t._v("AMD的实现也是采用require来实现的，但是不同于CommonJs，它有两个参数：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("module"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("callback"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("第一个参数[module],是一个数组，就是要加载的模块；第二个参数callback，就是加载成功之后的回调函数。如果将前面的代码改成AMD的形式，就是下面这样：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'math'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("math")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    math"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("math.add()与math加载不是同步的，浏览器不会发生假死，所以很显然浏览器比较适合AMD规范。目前"),a("code",[t._v("require.js")]),t._v("就实现了AMD规范。")]),t._v(" "),a("h5",{attrs:{id:"_2-为什么用require-js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-为什么用require-js","aria-hidden":"true"}},[t._v("#")]),t._v(" 2. 为什么用require.js?")]),t._v(" "),a("p",[t._v("最早的时候，所有的JavaScript代码都放在一个文件下，只要加载这一个文件就够了，后来代码越来越多，一个文件不够用了，必须分为两个文件或者更多文件，一次加载。就出现了这种形式：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("script src"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"a.js"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("script"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("script src"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"b.js"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("script"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("script src"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"c.js"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("script"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("script src"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"d.js"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("script"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("p",[t._v("这段代码依次加载多个js文件，不过这样的写法有很大的缺点：")]),t._v(" "),a("pre",[a("code",[t._v("1. 加载的时候，浏览器会停止渲染；\n2. 由于js文件之间有一定的依赖性，所以要保持js的先后顺序，否则就会出错。\n")])]),t._v(" "),a("p",[t._v("require.js的出现就是为了解决以上两个问题：")]),t._v(" "),a("pre",[a("code",[t._v("1. 实现js文件的异步加载，避免网页失去响应；\n2. 管理模块之间的依赖性，便于代码的编写和维护。\n")])]),t._v(" "),a("h4",{attrs:{id:"三、cmd"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、cmd","aria-hidden":"true"}},[t._v("#")]),t._v(" 三、CMD")]),t._v(" "),a("p",[t._v("大名远扬的玉伯写了seajs，就是遵循他提出的CMD规范，与AMD蛮相近的。")]),t._v(" "),a("p",[t._v("Sea.js 更贴近 CommonJS Modules/1.1 和 Node Modules 规范。Sea.js则专注于web端浏览器，同时通过node扩展的方式可以很方便跑在node环境中。")]),t._v(" "),a("p",[t._v("require.js想成为浏览器端的模块加载器，同时也想成为Rhino / Node等环境的模块加载器。")]),t._v(" "),a("h3",{attrs:{id:"四、-es6模块化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、-es6模块化","aria-hidden":"true"}},[t._v("#")]),t._v(" 四、 ES6模块化")]),t._v(" "),a("p",[a("a",{attrs:{href:"http://es6.ruanyifeng.com/#docs/module",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考阮一峰老师的教程"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("参考文献")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.cnblogs.com/moxiaowohuwei/p/8692359.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("1. js模块化编程之彻底弄懂CommonJS和AMD/CMD！"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/seajs/seajs/issues/277",target:"_blank",rel:"noopener noreferrer"}},[t._v("2. require.js与Sea.js的异同"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2012/10/javascript_module.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("3. Javascript模块化编程（一）：模块的写法"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("4. Javascript模块化编程（二）：AMD规范"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2012/11/require_js.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("5. Javascript模块化编程（三）：require.js的用法"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"http://es6.ruanyifeng.com/#docs/module",target:"_blank",rel:"noopener noreferrer"}},[t._v("6. 阮一峰ES6 Module的语法"),a("OutboundLink")],1)])])},[],!1,null,null,null);s.default=e.exports}}]);